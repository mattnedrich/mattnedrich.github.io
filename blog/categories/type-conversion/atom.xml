<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Type Conversion | Matt Nedrich]]></title>
  <link href="http://mattnedrich.github.io/blog/categories/type-conversion/atom.xml" rel="self"/>
  <link href="http://mattnedrich.github.io/"/>
  <updated>2014-02-14T11:57:29-05:00</updated>
  <id>http://mattnedrich.github.io/</id>
  <author>
    <name><![CDATA[Matt Nedrich]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Good ol' C Casting]]></title>
    <link href="http://mattnedrich.github.io/blog/2013/03/25/good-ol-c-casting/"/>
    <updated>2013-03-25T21:28:00-04:00</updated>
    <id>http://mattnedrich.github.io/blog/2013/03/25/good-ol-c-casting</id>
    <content type="html"><![CDATA[<p>Understanding data representation is important. Consider the following C code.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="predefined-type">float</span> foo = <span class="integer">5</span>;
<span class="predefined-type">int</span> bar = foo;
printf(&amp;ldquo;%d&amp;rdquo;, bar);
</pre></div>
</div>
 </figure></notextile></div></p>

<p>This little C snippet outputs the number 5, as is expected. Now, let&rsquo;s make a slight change. Instead of assigning foo to bar, lets cast it to an int by casting the address that foo is stored to an int pointer and then dereferencing it.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="predefined-type">float</span> foo = <span class="integer">5</span>;
<span class="predefined-type">int</span> bar = &lt;em&gt;(<span class="predefined-type">int</span>&lt;/em&gt;)&amp;amp;foo;
printf(&amp;ldquo;%d&amp;rdquo;, bar);
</pre></div>
</div>
 </figure></notextile></div></p>

<p>This time around we get the value 1084227584. That&rsquo;s certainly not 5 (as we observed the first time around), so what&rsquo;s going on here. As you may have guessed, integer and floating point numbers are stored differently.</p>

<h2 id="dissecting-floating-point-numbers">Dissecting floating point numbers</h2>
<p>Let&rsquo;s start with how the float value is stored in memory. Wikipedia gives us this handly IEE 754 single precision binary floating point representation diagram:</p>

<p><img width="500px" src="/images/c_casting/500px-Float_example.svg.png" /></p>

<p>The most significant bit denotes the sign of the number. The next 8 bits store what&rsquo;s called the exponent. Finally the last 23 bits store the fraction, also known as the mantissa. When determining the value stored in such a floating point number, the following approach is used.</p>

<script type="math/tex; mode=display">value = (1.0+fraction)\cdot 2^{(exponent-127)}</script>

<p>In our example we were storing the value 5. This can be computed as <script type="math/tex">1.25\cdot 2^2</script>. As a 32-bit floating point number this is stored as </p>

<p><script type="math/tex">{01000000101000000000000000000000}_2</script>. </p>

<p>We can partition this binary number into the three different segments defined in the above diagram:</p>

<p><script type="math/tex">\color{blue}0\color{green}{10000001}\color{red}{01000000000000000000000}_2</script>. </p>

<p>If we look at these numbers individually we see that the sign bit <script type="math/tex">\color{blue}{0}_2</script> tells us the number is positive. The exponent <script type="math/tex">\color{green}{100000001}_2</script> is equal to <script type="math/tex">129-127=2</script> in decimal. Finally the fraction <script type="math/tex">\color{red}{01000000000000000000000}_2</script> gives us <script type="math/tex">2^{-2} = 0.25</script>. </p>

<p>If we put these three peices together we see that they give us the number <script type="math/tex">5</script>, as </p>

<p><script type="math/tex">(1.0+fraction)\cdot 2^{(exponent-127)} = 1.25\cdot 2^2 = 5</script>.</p>

<h2 id="conclusion">Conclusion</h2>
<p>In the first snippet when we assigned foo to bar an implicit floating point to two&rsquo;s complement conversion happened. The result of this converion was then stored in bar&rsquo;s memory location. In the second snippet we cast foo to an integer and the bits that make up foo were copied verbatim and stored as bar. Because no conversion occured we ended up with a different result.</p>
]]></content>
  </entry>
  
</feed>
